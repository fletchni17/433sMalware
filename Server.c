#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <openssl/evp.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>

void printString(unsigned char* string, unsigned length){

    if(length !=0){

        for(int i =0; i<length; i++){
            printf(" %u ", string[i]);
        }
        printf("\n");

    }else{

        int end =0;
        int count = 0;
        while(!end){
            printf(" %u ", string[count]);
            if(string[count] ==0){
                end = 1;
                printf("\n");
            }
            count++;
        }
    }

}

//sets outLen to final length of decrypted key
//returns decrypted key
unsigned char* decryptTempKey(unsigned char* encTempKey, int encTempKeyLen, size_t* outLen){


    //assumes the pprivate key will always be name private.pem and be at same directory level
    FILE* privKeyFilePtr = fopen("private.pem", "r");
    if(!privKeyFilePtr){
        printf("Error opening private key file\n");
        return NULL;
    }

    EVP_PKEY * pubkeyPtr = PEM_read_PrivateKey(privKeyFilePtr, NULL,NULL, NULL);

    EVP_PKEY_CTX *ctx;
    EVP_PKEY *key;
    unsigned char * out;

    ctx = EVP_PKEY_CTX_new(pubkeyPtr, NULL);

    if (!ctx){
        printf("Error generating pubkey context\n");
        return NULL;
    }

    int retVal;
    retVal= EVP_PKEY_decrypt_init(ctx);
    if(retVal <1){
        printf("Error initializing pubkey context\n");
        return NULL;
    }

    retVal = EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING);
    if(retVal <1){
        printf("Error setting padding context\n");
        return NULL;
    }

    /* Determine buffer length */
    retVal = EVP_PKEY_decrypt(ctx, NULL, outLen, encTempKey, encTempKeyLen);
    if(retVal <1){
        printf("Error buffer length context\n");
        return NULL;
    }

    out = OPENSSL_malloc(*outLen);
    if (!out){
        printf("Error out buffer alloc\n");
        return NULL;
    }

    retVal = EVP_PKEY_decrypt(ctx, out, outLen, encTempKey, encTempKeyLen);
    if (retVal<1){
        printf("Error public encrypt\n");
        return NULL;
    }

    printf("Decrypted Key Size: %i\n", (int)*outLen);
    printf("Decrypt Key: ");
    for(int i =0;i <*outLen; i++){

        printf("_ %i",(int) out[i]);

    }
    printf("\n");



    return out;

    fclose(privKeyFilePtr);
}

unsigned char* receiveEncKey(){

    unsigned char* key;

    // Declare variables
    int domain = AF_INET;
    int type = SOCK_STREAM;
    int protocol = 6;//TCP
    struct sockaddr_in server_address;
    struct sockaddr_in client_address;

    char* ip = "172.31.146.244";

    int sockfd = socket(domain,type,protocol);
    if (sockfd == -1){
        printf("errorSocket\n");
        return NULL;
    }

    // this allows the port to be cleared instantly
    // we had a problem where server could not bind to port immediatly after closing.
    int option = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &option, sizeof(option));

    memset(&server_address, 0, sizeof(server_address));

    server_address.sin_family = domain;
    int portNumber = 1026;
    server_address.sin_port = htons(portNumber);
    in_addr_t ipConverted = inet_addr(ip);
    server_address.sin_addr.s_addr = ipConverted;

    // Bind to the set port and IP
    size_t size1 = sizeof(server_address);
    int retVal = bind(sockfd, (struct sockaddr *) &server_address, size1);
    if(retVal == -1){
        printf("errorBind\n");
        return NULL;
    }

    // Listen for clients:
    int backlog = 100;
    int error = listen(sockfd,backlog);
    if(error == -1){
        printf("errorListen\n");
        return NULL;
    }

    // Accept an incoming connection
    size_t size = sizeof(client_address);
    int clientfd = accept(sockfd, (struct sockaddr*) &client_address,(socklen_t *) &size);
    if(clientfd == -1){
        printf("errorAccept\n");
        return NULL;
    }

    // Receive client's message
    size_t inputBufferLength = 256;
    unsigned char inputBuffer[inputBufferLength];
    memset(inputBuffer, 0, sizeof(inputBuffer));

    ssize_t bytesRecieved = recv(clientfd,inputBuffer,inputBufferLength,0);
    if(bytesRecieved == -1){
        printf("errorReceive\n");
        return NULL;
    }
    else{
        printf("Recieved encKey: \n");
        printString(inputBuffer,inputBufferLength);
        printf("\n");

        size_t outLen;
        key = decryptTempKey(inputBuffer,inputBufferLength,&outLen);
    }

    size_t inputBufferPasswordLength = 30;
    unsigned char inputBufferPassword[inputBufferPasswordLength+1];
    memset(inputBuffer, 0, sizeof(inputBufferPassword));
    unsigned char password[10] = {'p','a','s','s','w','o','r','d',10,0};
    int passwordCorrect = 0;

    unsigned char* message;
    int messageSize = 0;

    while(!passwordCorrect){

        // Accept an incoming connection
        size_t size1 = sizeof(client_address);
        int clientfd1 = accept(sockfd, (struct sockaddr*) &client_address,(socklen_t *) &size1);
        if(clientfd1 == -1){
            printf("errorAccept\n");
            return NULL;
        }

        ssize_t bytes = recv(clientfd1,inputBufferPassword,inputBufferPasswordLength,0);
        if(bytes == -1){
            printf("errorReceive password\n");
            return NULL;
        }
        else{
            printf("Recieved password: \n");
            printString(inputBufferPassword,inputBufferPasswordLength);
            printf("\n");

            if(strcmp(password, inputBufferPassword) ==0){

                printf("Password correct!!!!!!: \n");
                passwordCorrect =1;
                message = key;
                messageSize = 32;
            }
            else{
                message = "0";
                messageSize = 1;
            }
        }

        ssize_t bytesSent = send(clientfd1, message,messageSize,0);
        if(bytesSent == -1){
            printf("errorSend\n");
        }
        else {
            printf("server responds: %s\n", message);
        }
    }

    //close the socket
    int val = close(clientfd);
    if(val == -1){
        printf("errorClose\n");
        return NULL;
    }
    return key;
}


int main(int argc, unsigned char** argv){

    unsigned char* decKey = receiveEncKey();
    if(decKey == NULL){
        printf("error final key\n");
    }
    else{
        printString(decKey,32);
    }
    return 0;
}
